> 흥달쌤의 [깨알 C언어](https://www.youtube.com/playlist?list=PLdaE6YENrbZA8sXCvVBUWjFwFI2zb4tlK0) 강의를 듣고 정리합니다.

# 포인터 배열

배열의 요소가 포인터(메모리주소)로 이루어진 것.

### 일반적인 배열

```c
char a[3] = {'a', 'b', 'c'};
printf("%s\n", a); //abc
```

`%s` : 문자열 출력

a의 주소값을 받아서 문자열을 출력하는 것이다. null을 만날때까지!

```c
char *str = "Hello";
printf("%s\n", str); //Hello
```

주소값 받아서 출력!

### 포인터변수

```c
char *student[3] = {"aaa", "bbb", "ccc");
```

포인터인데 배열로 만든 것!

기존 포인터는 하나의 주소만 가졌는데, 이건 포인터배열이라 `[3]` → 3열의 주소를 갖게 된다.

즉, 각각의 배열 요소에 주소값이 들어가는 것!

`“aaa”, “bbb”, “ccc”`는 문자열로 생성된다.

**가상의 주소를 설정했을 때 아래와 같은 구조**

| 20번지 | a   | a   | a   |
| ------ | --- | --- | --- |
| 30번지 | b   | b   | b   |
| 40번지 | c   | c   | c   |

**student 변수가 `100번지`를 가리킨다면 student 변수의 배열은 아래와 같다**

| 100번지 20번지 | 30번지 | 40번지 |
| -------------- | ------ | ------ |

### EX

```c
static char *c[] = {"aaa", "bbb", "ccc"};
printf("%s", *(c+1));
```

여기서 static은 큰 의미가 없다.

char 변수를 포인터 배열 변수로 생성 `100번지`

| 100번지 20번지 | 101번지 30번지 | 102번지 40번지 |
| -------------- | -------------- | -------------- |

| 20번지 | a   | a   | a   |
| ------ | --- | --- | --- |
| 30번지 | b   | b   | b   |
| 40번지 | c   | c   | c   |

c+1 하면 101번지의 값 → 30번지의 값을 다 출력하게 된다

결과 : bbb

### EX

```c
char *array1[2] = {"Good morning", "C language"};
printf("%s\n", array1[0]+5); //morning
printf("%c\n", *(array1[1]+6)); //u
```

1. array1을 2개의 열을 가진 포인터 배열 변수 char으로 선언

   array1 `100번지`

   | 100 20번지 | 101 50번지 |
   | ---------- | ---------- |

   | 20번지 | G[20번지]ood morning 한글자씩 |
   | ------ | ----------------------------- |
   | 50번지 | C[50번지] language 한글자씩   |

2. `printf("%s\n", array1[0]+5);`

   문자열 출력을 위해 주소값을 받는다.

   20+5 → 25번지부터 null 만날때까지 모든 문자를 다 출력하라는 뜻

3. `printf("%c\n", *(array1[1]+6));`

   50 + 6 → **\*56** = **56의 값** 글자 **한글자** 출력

### EX

```c
int a[2][3] = {{-3, 14, 5}, {1, -10, 8}};
int *b[] = {a[0], a[1]};
int *p = b[1];
printf("%d", *b[1]);
printf("%d", *(++p));
printf("%d", *(--p-2));
```

1. a를 행2 열3인 배열로 선언

   - a는 `100번지`

   | a[0] 100 | -3 100 | 14 101  | 5 102 |
   | -------- | ------ | ------- | ----- |
   | a[1] 103 | 1 103  | -10 104 | 8 105 |

2. 포인터배열 b 선언 `200번지`

   | b[0]             | b[1]         |
   | ---------------- | ------------ |
   | 200 a[0] 100번지 | a[1] 103번지 |

3. 포인터 p 선언 ← b[1]과 연결 (a[1]에 있는 주소니까)
   - `103번지`
4. `printf("%d", *b[1]);`
   - b[1]의 값 → a[1]의 값 → 1
5. `printf("%d", *(++p));`
   - p 1증가시킨 것의 값 ⇒ `104번지` 의 값= -10
6. `printf("%d", *(--p-2));`
   - `104`번지에 있는 p값을 -1 한 값에 -2
   - 104-3 = `101번지` 의 값
   - 14

### EX

```c
int num[4] = { 1, 2, 3, 4 };
int *pt = num;
pt++;
*pt++ = 5;
*pt++ = 10;
pt--;
*pt++ += 20;
printf("%d %d %d %d", num[0], num[1], num[2], num[3] );
```

num `100`

| n[0] 100 | n[1] 101 | n[2] 102 | n[3] 103 |
| -------- | -------- | -------- | -------- |
| 1        | 2        |
| → 5      | 3        |

→ 10+20
→ 30 | 4 |

pt `100`

1. pt 1 증가
2. pt의 값에 5 넣고 pt 1 증가
3. pt의 값에 10 넣고 pt 1 증가
4. pt 1 감소
5. pt += 20 하고 pt 1 증가
