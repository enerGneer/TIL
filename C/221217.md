> 흥달쌤의 [깨알 C언어](https://www.youtube.com/playlist?list=PLdaE6YENrbZA8sXCvVBUWjFwFI2zb4tlK0) 강의를 듣고 정리합니다.

# 진법변환

### 10진수 → 2진수

1. 2로 나눈다 (못 나눌때까지)
2. 32 16 8 4 2 1 을 쓰고 해당하는 곳에 1을 할당한다 (나머지는 0으로 채운다)

> 10진수 19 = 2진수 10011

10진수는 무한대야! 그래서 자리수 제한이 없다

### 2진수 → 8진수

8진수 : 0~7까지 표현

1. | 4 2 1 | 4 2 1 | ← 따라서 이렇게 된다 (세자리씩 잘린다) 4+2+1 = 7
2. | 0 1 0 | 0 1 1 | ← 각각 해당하는 부분을 변환
3. | 2 | 3 | ← 결과

> 10진수 19 = 2진수 10011 = 8진수 23 (이십삼이 아니라 이.삼.)

### 2진수 → 16진수

16진수 : 0~15까지 표현

1. | 8 4 2 1 | 8 4 2 1 | ← 따라서 4개씩 자른다 8+4+2+1 - 15
2. | 0 0 0 1 | 0 0 1 1 |
3. | 1 | 3 | ← 결과

> 10진수 19 = 2진수 10011 = 8진수 23 = 16진수 13 ( 일.삼.)

# 비트연산

## 비트연산자 종류

### `&` : AND 2개가 다 참일 때만 참 [논리곱]

- 5 & 3
  - 5 = 0101
  - 3 = 0011
    1. 0, 0 → 0
    2. 1, 0 → 0
    3. 0, 1 → 0
    4. 1, 1 → 1
    5. 0001 에 8421을 씌우면 1

### `|` : OR 2개 중 하나만 참이어도 참 [논리합]

- 5 | 3
  1. 0, 0 → 0
  2. 1, 0 → 1
  3. 0, 1 → 1
  4. 1, 1 → 1
  5. 0001 위에 8421을 씌워준다
  6. 결과 4, 2, 1 자리에 1이 있다
  7. 4 + 2 + 1 = 7

### `^` : XOR(exclusive or) 둘 중 하나만 틀려야지 참 [배타적 논리합]

- 5 ^ 3
  1. 0, 0 → 0
  2. 1, 0 → 1
  3. 0, 1 → 1
  4. 1, 1 → 0
  5. 8421 모자를 씌워주면
  6. 0110 이니까 4 + 2 = 6

### `~` : NOT

- ~5
  - 양수라면 하나 더하고 -를 붙인다
    - ~16 = -17
  - 음수면 하나 빼고 +를 붙인다
    - ~-16 = 15

## 예제

```c
#include<stdio.h>
void main(){
	int x = 0x11; //16진수 11
	// 16진수 11을 2진법으로 바꾸면 00010001
	// 10진법으로 바꾸면 17
	int y, z;
	y = x & 0x0f; // 0x0f는 00001111
	// AND 연산 결과값은 00000001
	// 10진수로 바꾸면 1 이걸 y에 대입
	z = x | 0x0f;
	// OR 연산을 하면 00011111
	// 10진수로 바꾸면 16+8+4+2+1 = 31이 z에 대입된다
	printf("x=%d, y=%d, x=%d, x, y, z);
	// x=17, y=1, z=31
}
```

앞에 0x를 붙이면 16진수, 0을 붙이면 8진수

- 0x0f
  1. 앞자리는 000
  2. f는 다 차있는 것. 따라서 f는 1111
     - 16진수인 경우 0~9를 숫자로 쓰고
     - 10=A, 11=B~ **15=F**가 된다
- 10진수로 바꿀때는 32 16 8 4 2 1 모자를 씌우면 된다
