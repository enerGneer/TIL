# Section 2. 객체지향 설계

# 1. 객체지향 (OOP, Object Oriented Programming)

요즘에 나오는 프로그래밍 언어 대부분. (JS는 예외로 상속 같은 개념은 없다)

C, 코볼 등이 절차지향 언어

## 개념

객체object로 나누고

구조를 만들어

객체의 행동method와

고유한 값attribute(속성)을 정의하여 설계

현실 세계의 유형일 수도 있고 무형일 수도 (회원, 주문, 상품 등)

(이 객체 안에 메서드도 있고 속성도 있고)

> 이해를 하자

## 구성요소 ⭐

### 클래스 Class ⭐

> 구조

유사한 유/무형의 존재를 **속성(멤버 변수)**과 **연산(method:속성의 값을 바꿀 수 있다)**을 정의해서 만든 **틀**.

- 다른 클래스와 독립적으로 디자인한다.
- 데이터를 추상화 하는 단위 (공통의 성질로 묶을 수 있는 단위)
  - 추상화한 걸 상속받아서 자기만의 고유한 틀을 만들 수 있다.

### 객체 Object

- 클래스의 인스턴스
  - 자바로 예시를 들면
    - User a = new User()
    - User라는 구조(Class)로 a라는 인스턴스를 만들게 된다.
    - User가 갖고 있는 구조 그대로 (속성, 연산 등) 갖고 **메모리에 올라간다**. (틀은 올라가지 않는다)
    - **실제로 메모리에 올라간 상태**가 객체 인스턴스.
- 객체는 자신 고유의 속성을 가진다
  - a도 User 클래스 안에 있는 항목들을 가지고
  - b도 가진다.
    - 즉 같은 걸 공유하는 게 아니라는 뜻

### 속성 Attribute = 멤버변수

- 객체들이 가지고 있는 고유한 값을 단위별로 정의
- 성질, 분류, 수량, 현재 상태 등
  - ex. ID, PW, 전화번호 등

### 메서드 Method

- 속성에 있는 값을 변경시킬 수 있는 연산.
- 어떤 특정한 작업을 수행하기 위한 명령문의 집합.

### 메세지 Message

- 객체 간 상호작용
  - 객체의 메서드를 호출하여
- 객체에게 어떤 행위를 하도록 지시

## 특징 ⭐

### 캡슐화 Encapsulation

- 데이터attribute와 데이터를 처리하는 행동method을 하나로 묶은 것
- 캡슐화된 객체의 세부내용은 외부에 은폐된다
  - 오류의 파급 효과가 적다
- 객체들 간 메시지를 주고받을 때 해당 객체의 세부 내용을 알 필요가 없으므로,
  - 인터페이스가 단순해지고, 결합도가 낮아진다.
    - 독립성 높아짐
      - 재사용용이

### 정보은닉 Information Hiding

- 캡슐화의 핵심 개념
- 다른 객체에게 자신의 데이터를 숨기고, 자신이 정의한 행동만을 통하여 접근을 허용.

### 상속 Inheritance

- extends로 상위클래스의 모든 데이터 **(프라이빗 제외)** 행동을 하위 클래스가 물려받는 것
- 상위클래스의 데이터와 행동을 자신의 클래스에 다시 정의하지 않아도 됨
  - +a 로 추가도 가능
- 상위 클래스 요소들을 사용할 수 있기 떄문에
  - 소프트웨어 재사용을 증대시키는 **중요한 개념.**

### 다형성 Polymorphism

(형태가 다양한 성질)

각 객체가 가지고 있는 여러 가지 방법으로 응답할 수 있는 개념

1. 오버로딩
   - 똑같은 이름의 메서드를 여러개 만드는 것
   - 메서드명은 똑같고 인자가 다른 경우
     - a(), a(), a(x,y)
2. 오버라이딩
   - 상속관계에서만 존재
   - 부모로부터 물려받은 걸 재정의

### 추상화 Abstraction

> 중요하다! 디자인 패턴의 거의 대부분의 클래스구조가 추상화 구조를 띠고 있다.

- 공통적인 부분들만 모아놓은 것
- 공통적인 특성을 상위클래스에서 정의하고, 하위클래스가 해당 메소드를 재정의하는 것

## 객체지향 설계원칙 SOLID ⭐⭐⭐

### 단일 책임 원칙 SRP Single responsibility principle

- 하나의 클래스는 하나의 책임만을 가져야 한다.

### 개방 폐쇄 원칙 OCP Open-closed principle

확장에는 열려있고 수정에는 닫혀있자

- 잘 설계해서 수정하지 말자 = 기존 코드 변경X Closed
  - 수정할 일이 있으면 확장으로 (상속받아서~) = 기능을 추가할 수 있도록 Open 설계하자

### 리스코프 치환 원칙 LSP Liskov substitution principle

- 하위클래스는 언제나 상위클래스를 대체할 수 있어야 한다.
- 상위클래스가 들어갈 자리에 하위클래스를 넣어도 계획대로 작동해야 한다.

### 인터페이스 분리 원칙 ISP Interface Segregation Principle

- 쓸데없는 인터페이스 만들지 마라 (내가 진짜 사용할 것만 만들어라)

### 의존성 역전 원칙 CIP Dependency Inversion Principle

- 의존 관계 맺을 때 변화 거의 없는 것에 의존해야
  - 자주 변화하는 건 X
- 구체적 클래스 X. 인터페이스나 추상 클래스와 의존 관계를 맺어야 한다.
  - 추상화!

> 이런 식으로 설계의 방향을 잡으라는 지침

# 2. 디자인 패턴 Design Pattern

## 개념

선인들이 이렇게하면 더 효율적인 설계가 가능하다고 만들어 준 가이드

> **실무를 시작하면 꼭 공부하자!**

- 재사용할 수 있도록 만들어놓은 패턴들의 모음
- 효율적인 코드를 만들기 위한 방법론

## 구성요소 ⭐

1. 이름과 유형
2. 문제 및 배경
3. 솔루션 : 패턴 이루는 요소 관계, 협동과정
4. 사례
5. 결과 : 적용했을 때의 이점과 영향
6. 샘플 코드 ⭐

## GoF(Gang of Four) 디자인 패턴 ⭐

- 각각 디자인 패턴을 생성, 구조, 행위 3가지로 분류

1. **생성**패턴 Creational
   - 객체 **생성**할 때 이렇게 생성하면 더 효율적으로 생성할 수 있더라
   - 추상화 방법 (디자인 패턴은 죄다 추성화!)
   - 종류
     - 추상 팩토리
     - 빌더
     - 팩토리 메소드 : 찍어내는 패턴 - **위임하여 캡슐화**
     - 프로토타입 : 원본-시제품 복사
     - 싱글톤 : 인스턴스가 하나임을 보장함 (참조는 하나만!)
2. **구조**패턴 Structural
   - 구조를 접목시킬 때 이렇게 하면~
   - 클래스나 인터페이스 합성
   - 클래스 객체 조합해 더 큰 구조로 만든다
   - 종류
     - 어댑터 : 변환
     - 브리지 : 분리해서 확장할 수 있도록
     - 컴포지트 : 객체들의 관계를 **트리 구조**로 구성
     - 데코레이터 : **덧붙인다**
     - 퍼사드 ⭐ : 서브시스템에 있는 인터페잉스 집합에 대해 하나의 통합된 인터페이스 Wrapper 제공
     - 플라이웨이트 : 공유로 메모리 절약
     - 프록시 : 객체의 대리surrogate나 대체글placeholder을 제공
3. **행위**패턴 Behavioral
   - 뭔가 그 객체들이 동작하면서 나타나는 패턴들
   - 클래스나 객체들이 상호작용하는 방법 정의
   - 결합도 최소화를 도운다
   - 종류
     - 책임 연쇄 : 연쇄적으로 묶어 요청 처리하는 객체 만날때까지
     - 커맨드
     - 인터프리터 : 특정 **언어**의 문법 표현 정의
     - 반복자
       - 자바의 iterator라는 클래스는 배열 형태다
     - 중재자
     - 메멘토 : 특정 상태로 다시 되돌아올 수 있도록 내부 상태 실체화
     - 옵저버 : 변화를 감지
     - 상태 : 상태에 따라~
     - 전략 : **알고리즘**군 정의
     - 템플릿 메소드 : 상위클래스는 **골격**만 작성 구체적 처리는 서브클래스에 위임
     - 방문자

> 실무에서는 이런 종류보다 코드가 중요하기 때문에 시험용으로 알아두자.
