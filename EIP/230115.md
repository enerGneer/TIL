# Section 2. 데이터베이스 물리속성 설계

성능을 끌어올리기 위한 작업

## 1. 파티셔닝

DB를 여러 부분으로 분할하는 것

- 장점
  - 가용성
  - 관리용이성
  - 성능
- 단점
  - 조인 비용 증가

### 샤딩 sharding

나누는 것. **샤드**를 만든다.

### 종류

- 수평 분할
  - 각 행들 분할
- 수직 분할
  - 컬럼 기준 분할
  - 자주 사용하는 컬럼 등을 분리시킴

### 분할 기준

- 범위 분할
  - 파티션 키 위주로 검색이 자주 실행될 때
  - 월별 분기별
- 목록 분할
  - 해당 컬럼의 조건이 많이 들어오는 경우
  - 한국, 일본, 중국 → 아시아 / 노르웨이, 스웨덴, 핀란드 → 북유럽
- 해시 분할
  - 해시 함수 적용하고 그 값으로
- 라운드 로빈 분할
  - 균일 분배
- 합성 분할
  - 위 기술들 복합적으로 사용

## 2. 클러스터 설계

클러스터란 자주 사용되는 테이블 데이터를 디스크 같은 위치에 저장시키는 방법

물리적 저장 방법

### 특징

- 클러스터된 테이블 사이 조인 발생할 경우 처리시간 단축
- **데이터 분포도가 넓을수록 유리 (= 분포도가 높다 = 분포도가 안 좋다)**

### 클러스터 대상 테이블

- 분포도가 넓은
- 대량의 범위를 자주 조회하는
- 입력 수정 삭제가 자주 발생하지 않는
- 자주 조인되어 사용되는 테이블

## 3. 인덱스

추가적인 저장 공간을 활용하여 검색 속도 향상시키기 위한 자료구조

### 종류

1. 클러스터드 인덱스
   - 테이블당 1개만 허용. 물리적 정렬
   - 인덱스 자체의 리프 페이지가 곧 데이터
   - 입력 수정 삭제 시 항상 정렬 상태 유지 → 성능 저하
2. 넌클러스터드 인덱스
   - 테이블당 약 240개의 인덱스 생성 가능
   - 인덱스 페이지만 정렬 (레코드 원본은 저장 안됨)
     - 인덱스 자체의 리프페이지는 데이터가 아니라 포인터라서
     - 검색 속도는 더 느리지만 입력 수정 삭제는 더 빠름
   - 용량을 더 차지
3. 밀집 인덱스
   - 데이터 레코드 각각 하나의 인덱스 생성
4. 희소 인덱스
   - 그룹 당 하나의 인덱스

### 구조

1. 트리 기반 인덱스 : 일반적인 방법, B+트리인덱스를 주로 사용
2. 비트맵 인덱스 : 비트를 이용
3. 함수 기반 인덱스
4. 비트맵 조인 인덱스
5. 도메인 인덱스 : 개발자가

### 인덱스 컬럼의 선정

- 분포도가 좋은 (10~15%) = 적당히 낮은 컬럼 (넓은 건 클러스터다!)
- 자주 조합되어 사용되는 경우 결합 인덱스를 생성 → 컬럼을 합치는 것
- 가능한 수정이 빈번하지 않은 컬럼을 선정
- 한 컬럼이 여러 인덱스에 포함되지 않도록 설계
- 기본키 및 외부키가 되는 컬럼을 선정

### 분포도에 대해

- DB에서 "분포도가 좋다."라 표현하는 것은 *해당 컬럼의 유니크한 데이터 종류가 많다*
  라고 이해 - 출처 [https://jdm.kr/blog/169](https://jdm.kr/blog/169)
- 예시1
  - 성별을 분석해보면 **분포도(selectivity)가 너무 안 좋다 (높다)**
    - 모든 자료의 값이 남/여 2가지중 하나라서
  - 이러한 데이터를 가지고 인덱스를 생성하면 효과를 보기보다는 오히려 손해를 본다
- 예시2
  - col_1 컬럼 : 전체 건수 100건, 값들은 모두 A, B, C 의 3가지뿐일 경우
    - 분포도(selectivity) : **3%** (값/전체건수 : 3/100 \* 100)
  - col_2 컬럼 : 전체 건수 100건, 값들은 모두 1, 2, 3, 4, 5, 6 의 6가지일 경우
    - 분포도(selectivity) : **6%** (값/전체건수 : 6/100 \* 100)
  - 출처 [https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kang_sok&logNo=60057985829](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=kang_sok&logNo=60057985829)
- **선택성(Selectivity) : Index를 구성하기 위해, 한 릴레이션에서 어떤 속성을 선택할지의 문제**
  - 선택성이 좋다는 것은 수많은 데이터의 바다 속에서 내가 원하는 값만을 딱 집어올릴 수 있을 확률이 좋다는 것이다.
    - **선택성이 좋으려면 분포도가 낮아야 한다.**
      - **분포도가 낮다는 것은 자료가 밀집되어 있지 않고 중복이 적다는 뜻이다.**
  - 선택성이 좋지 않은 = **분포도가 높은 예**
    - **성별. 남자/여자**로 나누는 경우 모집단의 반반으로 나뉘는 것 말고는 별 소득이 없을 것이다.
      - 분포도가 높다 = 선택성이 나쁘다 = 인덱스로 사용하기 안 좋다
      - 선택성이 좋다 = 분포도가 낮다 = 인덱스로 사용하기 좋다
  - 출처 [https://an-onymous.tistory.com/entry/Index-선택성-데이터베이스가-데이터를-빠르게-검색하는-방법](https://an-onymous.tistory.com/entry/Index-%EC%84%A0%ED%83%9D%EC%84%B1-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B0%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EA%B2%80%EC%83%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95)

## 4. 뷰

= 외부스키마

가상 테이블. 노션의 데이터베이스 뷰를 생각하자.

### 특징

- 기본 테이블과 구조 동일, 조작도 거의 동일
- 가상 테이블 = 물리적으로 구현X
- 데이터의 논리적 독립성 제공
- 뷰를 통해서만 데이터에 접근하게 하는 것으로 뷰에 나타나지 않는 데이터 안전하게 보호
- 데이터의 삽입, 삭제, 갱신에 제한.
- 기본 테이블 삭제하면 뷰도 삭제돔.
- CREATE로 생성, DROP으로 삭제.
- ALTER로 변형-수정이 불가.

### 장점

- 논리적 데이터 독립성 제공
- 접근제어로 자동 보안 제공

### 단점

- 가상이라서 인덱스(물리)를 가질 수 없다
- ALTER 불가 = 수정 불가
- 삽입 삭제 갱신 연산에 제약 따르다

## 5. 데이터베이스 백업

백업 - 복구restore

### 방식

- 전체 백업 full backup
- 증분 백업 : 풀 백업 이후 변경-추가된 데이터만 백업
- 차등 백업 : 풀 백업 이후 변경-추가된 데이터 모두 포함하여 백업
- 실시간 백업
- 트랜잭선 로그 백업 : insert, update, delete

### 복구시간 목표

RTO 허용되는 최대 지연 시간

### 복구시점 목표

RPO 허용되는 데이터 손실량

# Section 3. 물리 데이터베이스 모델링

## 데이터베이스 무결성

### 종류

1. 개체 무결성
   - 모든 릴레이션은 기본 키로 선택된 컬럼을 가져야 한다
   - 기분키는 중복되지 않은 고유한 값을 가져야
   - 기본키는 NULL 값을 허용하지 않는다
2. 참조 무결성
   - 외래키 값은 NULL or 참조하는 릴레이션의 기본키 값과 동일해야
   - 각 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다
   - 제약조건
     - 제한 : 문제 연산 거절
     - 연쇄 : 참조하는 튜플도 함께 삭제
     - 널값 : 참조표에서 튜플 삭제하고 베이스표에서 이 튜플을 참조하는 튜플들 외래키에 NULL 등록
     - 기본값
3. 도메인 무결성
   - 속성들의 값은 정의된 도메인에 속한 값이어야 한다
4. 고유 무결성
5. 키 무결성

## 키 종류

### 키 key

다른 튜플들과 구별할 수 있는 유일한 기준이 되는 컬럼

### 종류

슈퍼키(유일성) > 후보키(유일성&최소성) > 기본키 & 대체키

## 컬럼 속성

컬럼 : 정보 나타내는 최소 단위

### 속성

도메인이 원자값

도메인 : 속성이 가질 수 있는 값의 범위

- 세부 의미에 따른 분류
  - 단순 속성
  - 복합 속성

## 반정규화

성능향상과 개발 편의성을 위하여 행해지는, 정규화 기법에 위배되는 기법

### 고려사항

- 데이터 중복 발생 → 무결성 깨질 수 있다
- 읽기 속도 향상, 삽입 삭제 수정 속도 저하
- 저장공간 효율 저하
- 유지보수 어려워짐
- 과도하면 성능 저하 유발
- 우선순위 고려해야

### 적용순서

1. 반정규화 대상 조사
2. 다른 방법으로 유도
   - 뷰
   - 인덱스
   - 클러스터링
   - 파티셔닝
   - 로직 변경
3. 반정규화 수행

### 유형

- 테이블 분할
- 테이블 중복
- 컬럼기반 분할
- 컬럼 중복 : 보통 이걸 많이 한다

# Section 4. 물리 데이터 모델 품질검토

## 물리데이터 모델 품질 기준

**성능**

### 항목

- 정확성, 완전성, 준거성, 최신성, 일관성, 활용성
  - 논리데이터와 동일

### 데이터 품질관리 대상

- 데이터 값
- 데이터 구조
- 데이터 관리 프로세스

## CRUD 분석

Create

Read

Update

Delete

- CRUD Matrix : 시스템 구축 시 프로세스와 DB에 저장되는 데이터사이의 의존관계를 표현하는 표
  - 트랜잭션 분석

## SQL 성능 튜닝

보통 SQL 문장 튜닝을 뜻한다

### 옵티마이저

- DB 내부에서 자체적으로 최적화
- 구분
  - 규칙기반 옵티마이저
  - 비용기반 옵티마이저

### Row Migration / Row Chaining

데이터가 수정되면서 더 커져서 기본 블록에 못 들어가는 경우

- Row Migration
  - 다른 블록에 데이터를 넣고, 기존 블록 위치에는 링크를 남긴다.
- Row Chaining
  - 블록 두 개에 이어서 한 Row를 저장
