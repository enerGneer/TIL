# Section 2. 요구사항 확인

고객의 머릿속에 있는 것을 구체화.

## 1. 요구분석 기법

### 요구공학

고객 요구를 전반적으로 관리하는 기법 (체계화하는 학문)

### 요구공학의 필요성

> **이해를 하자**

1. 분석이 어렵기 때문에
   - 업무에 대한 이해가 부족한 개발자, 의사소통, 잦은 요구사항 변경
2. 요구사항 변화
   - (고객의 마음은 갈대)
3. 관점별 차이 발생
   - 최대한 협의점을 찾아가는 과정.

### 요구사항 개발 프로세스⭐

도출 Elicitation → 분석 Analysis → 명세Specification → 확인 Validation

1. 도출
   - 고객의 요구를 머릿속에서 끄집어내는 과정
   - 고객 니즈 이해, 요구사항 어디있고 어떻게 수집할 것인지
   - **요구사항 도출 기법 ⭐**
     - **인터뷰**
     - **관찰** (고객사의 업무 프로세스 관찰) 또는 문화기술적 연구
     - **사용자 스토리** (여러 사람의 업무에 관한 얘기를 하나씩 받는다)
     - **시나리오** (요구사항 절차적으로, 이야기식으로 나열)
     - **설문조사**
     - **브레인 스토밍**
     - **포커스 그룹** (이해관계자들이 모여서 회의)
     - **워크샵**
2. 분석
   - 요구사항 기능별로 **분류**
     - 개념 모델링( = 대충 그림)
     - 가능한 작업인지 확인
       - 상충되는 요구사항 해결
     - 요구사항 협상
     - 소프트웨어의 범위 파악
   - 구조적 분석 도구 (구조적 = 절차적)
     - 이런 것들이 있다는 걸 알아두기. 나중에 하나하나 다룬다!
       - DFD (Data Flow Diagram) : 데이터 흐름도
       - Data Dictionary : 자료 사전 (그 데이터의 상세한 내용)
       - Mini-Spec : 소단위 명세서
       - ERD (Entity Relationship Diagram) : 개체 관계도
       - STD (State Transition Diagram) : 상태 전이도
   - 객체지향 분석 도구
     - UML (Unified Modeling Language) : 시스템을 그림으로 표현
     - 모델링
       - 구조적, 객체지향을 굳이 분리해서 기억할 필요는 없다.
   - 도메인 분석
     - 이라는 것도 있다는 걸 알아둔다.
3. 명세
   - **정리, 명세화**
     - 전체적인 구조를 **문서화**
     - 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성한다.
   - **요구사항 명세 기법**
     1. 정형 명세 기법
        - 그림이나 수식으로 표현되는 것
          - 수학, 논리학 기반
            - **수학적이다!**
          - 언어 종류 : **Z**
     2. 비정형 명세 기법
        - 서술하듯이 글로 쓰는 것
          - 자연어, 그림중심
          - 약간 애매할 수 있다. (사용자-개발자 간 오해 있을수도)
   - 산출물 (작성했으니까 당연히 나오는 것들)
     - 시스템 정의서, 시스템 요구사항 명세서, 소프트웨어 요구사항 명세서
4. 확인
   - 고객과 **확인**
     - 이해관계자들이 모여 명세를 검토한다.

### 요구사항 분석 기법

1. 요구사항 분류
   - 기능 비기능 분류
2. 개념 모델링
   - 머릿속에서 끄집어낸 걸 (개념적으로) 그림을 그린다
   - 주로 UML을 사용하여 표기한다
3. 요구사항 할당
4. 요구사항 협상
5. 정형 분석 (Formal Analysis)
   - 구문과 의미를 갖는 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현 → 분석하는 과정

## 2. UML (Unified Modeling Language)

크게 두 가지 다이어 그램이 나오게 된다

1. 구조 다이어그램
   - 정적인 것 (아이디 패스워드 전화번호 등)
2. 행위 다이어그램
   - 내가 주문하는 절차

### UML 개념

프로그램 설계를 표현하기 위해 사용하는 표기법

개발, 기획 서로 알아보기 쉽게 만드는 것

### UML 특징 ⭐

1. 가시화 언어
   - 시각적 그래픽이니까
2. 명세화 언어
   - 작성했으니 문서로 남을 수 있다
3. 구축 언어
   - 이것을 가지고 개발을 하니까
   - 명세화된 모델을 소스코드로 변환 → 이게 잘 안되기에 개발자가 필요하다
4. 문서화 언어
   - 일련의 과정을 문서로 남겨 계속 유지 보수한다.

### UML 구성요소 ⭐

1. **사물 Things**
   - 모델을 구성하는 가장 중요한 기본 요소
   - ex. 회원
2. **관계 Relationships**
   - 사물과 사물 사이 연관성
   - 회원이라는 사물과 주문이라는 사물은 관계를 맺는다
3. **다이어그램 Diagram**
   - 위의 사물과 관계를 도형으로 표현한 것

### 사물

- 구조사물
  - 정적
- 행동사물
  - 동적
- 그룹사물
  - 패키지 다이어그램
- 주해사물
  - 주석, 노트같은 부가적 설명

### 관계

- **일반화 관계 Generalization**
  - 상속관계 : 한 클래스가 다르 클래스를 포함하는 상위 개념일 때의 관계
    - 객체지향 개념에서는 일반화 관계를 상속관계라고 한다.
- **연관관계 Accociation**
  - 2개 이상의 사물이 서로 관련된 관계
  - 한 클래스가 다르클래스에서 제공하는 기능을 사용할 때 표시
  - ex. 사람—휴대폰
- **의존관계 Dependency**
  - 연관 관계와의 유사성
    - 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때
  - 연관 관계와의 차이점
    - 두 클래스의 관계가 한 메서드를 실행하는 동안과 같이 **매우 짧은 시간만 유지된다.**
      - 아주 잠깐만 사용하는 것
  - ex. 학생…색연필
- **실체화 관계 Realization**
  - 추상적으로 공통된 성질을 만들고 이것으로 구현하는 것
    - 추상화란?
      - 공통적인 성질을 묶어놓는 것
  - ex. 리모콘의 틀이라는 공통된 성질을 두고, 이걸 가지고 선풍기, TV, 에어컨 등에서 구현하는 것 = 추상화
- **집합 관계**
  - **집약 관계 Aggregation**
    - 뒤에 나올 합성관계와 구분할 것
    - **`has a` 관계**
      - 한 객체가 다른 객체를 소유한다.
    - 전체 객체의 라이프타임과 부분 객체의 라이프타임은 **독립적**
      - ex. 불고기—간장, 다시다, 미원
        - 다시다나 미원이 없어도 된다는 뜻 (맛은 없겠지만!)
  - **합성 관계 Composition**
    - **집약 관계와의 중요한 차이점**
      - **긴밀한 필수적 관계 (부분 객체가 전체 객체에 속하는 관계)**
        - **없으면 절대 안됨**
    - 전체 객체의 라이프타임과 부분 객체의 라이프타임은 의존적이다
      - ex. 책상—책상 다리, 상판, 나사
        - (부러지면 버려야 한다!)

### 다이어그램

종류는 실무에서는 많이 쓰이는 것이 정해져 있으므로 시험용으로만 알아두자.

1. 구조 다이어그램 (정적)
   - **클래스 다이어그램** ✅ 대표적!
     - 클래스 속성과 클래스 사이의 관계를 표현
     - ex. User 안에 ID, PW 등등이 있다
   - 객체 다이어그램
     - 하나의 인스턴스가 특정 시점에 만들어졌을 때 그걸 객체 다이어그램이라고 한다.
       - 클래스 다이어그램에서 만들어지게 된다
     - ex. 유저 한명이 들어온다 = 인스턴스가 생긴다
   - 컴포넌트 다이어그램
     - 컴포넌트 사이 관계
   - 배치 다이어그램
     - 어디에 무엇을 배치했는지 (위치, 노드, 통신경로)
   - 복합체 구조 다이어그램
     - 복합 구조를 가질시
   - 패키지 다이어그램 ✅
     - 클래스 다이어그램을 관련있는 것들 끼리 묶어 패키지로 만든 것
2. 행위 다이어그램 (동적)
   - 구조 다이어그램이 변화할 때 만들어진다
   - **유스케이스 다이어그램 Use Case** ✅ 대표적!
     - Actor(사용자나 외부 시스템)가 어떤 기능을 수행하는지
   - 순차 다이어그램 Sequence
     - 특정 행동이 어떤 순서로 어떤 객체와 상호작용하는지 표현
   - 커뮤니케이션 다이어그램
     - 주고받는 메시지 같은 연관관계까지 표현
   - 상태 다이어그램
     - 객체가 어떤 상태로 바뀌는지, 상태변화, (구조 다이어그램의 상태 변화)
   - 활동 다이어그램
     - 어떤 기능 수행하는지
   - 상호작용 다이어그램
     - 상호작용 다이어그램 간 제어 흐름 표현
   - 타이밍 다이어그램
     - 객체 상태 변화와 시간 제약

### UML 확장 모델 스테레오 타입

그냥 이 기능이 확장된 것 = 스테레오 타입

`<<  >>`를 사용해 확장 요소를 나타낸다

- ex. `<<interface>>` : 인터페이스 클래스

### 클래스 다이어그램 ⭐

고객이라는 클래스가 있고, 변수랑 메서드가 있다는 걸 하나의 박스로 그림. → 그리고 이런 클래스들간의 관계를 표시

- 접근제한자 (나중에 자세히)
  - `-` private : 해당 클래스 안에서만 접근 가능
  - `#` protected : 상속이거나, 동일 패키지 안에서 사용 가능
  - `+` public : 아무나 다 사용 가능

### 유스케이스 다이어그램 ⭐

- 구성요소

  1. 시스템 : 만들고자 하는 프로그램 명칭 ex. 로그인
     - 네모박스
  2. 액터 Actor : 외부시스템, 사용자 등 (사스템과 상호작용을 하는 외부에 있는 사람 or 시스템)
     - 졸라맨
  3. 유스케이스 Usecase : 사용자 입장에서 바라본 시스템의 기능 (어떤 시스템 안에서 어떤 액터가 어떤 기능을 수행한다)
     - 타원형
  4. 관계 Relation : 액터와 유스케이스 사이의 의미있는 관계

     > **포함관계와 확장관계 구분하기!!**

     - 연관 관계 Association
       - 액터와 유스케이스간의 상호작용
       - 실선으로 연결
         - ex. 사용자가 글을 등록하는 경우
     - **포함 관계 include**
       - 유스케이스를 수행할 떄 **반드시** 실행되어야 하는 경우
         - ex. 액터가 글을 쓰고 싶은 연관관계가 있을 때 로그인을 반드시 해야 한다 `<<include>>`
     - **확장 관계 Extend**
       - 유스케이스를 수행할 때 특정 조건에 따라 확장 기능 유스케이스를 수행하는 경우
         - **해도 되고 안해도 된다**
         - ex. 글을 등록할 때 파일을 첨부하는 것 (반드시 하지 않아도 되는 것) `<<extend>>`
     - 일반화 관계 Generalization
       - 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스
         - **상속**받는 것
         - ex. 글을 검색한다←글쓴이로 검색, 날짜로 검색

### 시퀀스 다이어그램

순차적으로 흘러가는 것

- 구성요소
  - 객체와 생명선(라이프라인)
  - 활성박스
  - 메시지
- 오브젝트 사이의 상호작용 관계

### 상태 다이어그램

한 객체의 상태가 변화할 때

시작이 있고 끝이 있다

ex. 주문→결제 준비 → 결제 대기 / 결제 실패 등

> **종류들은 필기에서 매번 출제가 된다.**

## 3. 애자일 Agile

애자일 개발을 가능하게 해주는 다양한 방법론 전체

프로젝트를 시작한 후 끊임없이 개선 노력을 하는 것

- 기존 소프트웨어 개발 방법론의 문제점을 개선하기 위해 등장
  - 고객의 요구사항을 그때그때 수용하자!

### 종류

- **XP (eXtream Programming)**
  - 문서보다는 코드를 중시
  - **5가치 핵심가치** ⭐
    - 용기
      - 요구사항에 능동적 대처
    - 존중
      - 개발자 역량 존중, 권한, 권리 부여
    - 의사소통
      - 개발자, 관리자, 고객 간의 원활한 의사소통
    - 피드백
      - 의사소통에 따른 즉각적인 피드백
    - 단순성
      - 부가적 기능, 사용되지 않는 구조와 알고리즘은 배제
  - 12개 실천사항
    - 짝 프로그래밍
    - 계획 세우기
    - 테스트 기반 개발
    - 고객 상주
    - 지속적인 통합
      - 지속적으로 소스코드를 모아야 한다 (개발자가 여럿이니까)
    - 코드 개선
    - 작은 릴리즈
      - 릴리즈=배포 (사용자가 받아볼 수 있도록 하는 것)
      - 조금 수정되면 그때그때 올리자
    - 코딩 표준
    - 공동 코드 소유
    - 간단한 디자인
    - 시스템 메타포어
      - 최종적으로 개발되어야 할 시스템 구조를 조망
    - 작업시간 준수
- **스크럼 SCRUM**
  - 특징
    - 개발 주기 **30일** 정도, 주기마다 실제로 동작하는 결과 제공
      - 스프린트 단위가 30일 sprint
    - 항상 팀 단위로 생각
    - 날마다 **15분** 정도 회의
  - 주요 개념
    - 스프린트 백로그 30일
    - 일일 스크럼 회의 15분
    - 실행 가능한 제품
- 그 외의 애자일 방법론 종류
  > **종류만 알아두자**
  - 크리스털 Crystal
  - FDD (Feature-Driven Development)
  - ASD (Adaptive Software Development)
  - 린 (Lean)
