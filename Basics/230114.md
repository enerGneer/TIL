> [Crash Course: Computer Science](https://www.youtube.com/playlist?list=PLH2l6uzC4UEW0s7-KewFLBC1D0l6XRfye)

# 최초의 프로그래밍 언어

하드웨어 차원에서 프로그래밍하는 건 번거롭고 어렵다.

그래서 등장한 것이 소프트웨어.

하드웨어는 원시 이진 명령어를 처리한다.

컴퓨터가 사용할 수 있는 유일한 언어 : 기계어

먼저 종이로 고수준 언어(=의사 코드 pseudo-code)를 작성하고

이진 기계어로 opcode table 같은 걸 사용하여 번역

### 어셈블러

1940-50년대에 약간 더 높은 수준의 언어 개발

opcode에는 mnemonics 니모닉이라는 간단한 이름을 지정했다.

어셈블리 언어를 읽어 기계어로 번역

자동으로 JUMP 주소를 파악하는 등 기능이 있다!

그러나 한계

기계어에 일대일 매핑되는 어셈블리어.. 따라서 기본 하드웨어에 묶여있는 한계가 있다 (어떤 레지스터와 메모리를 사용할지 생각해야함.)

그래서 Hopper는 (최초의) 컴파일러를 고안한다.

### IBM에서 만든 Fortran

초기 컴퓨터 프로그램을 지배한 fortran.

더 많은 코드를 더 빠르게 읽을 수 있게 되었다.

### COBOL

1950년대 대부분의 프로그래밍 언어와 컴파일러는 단일 유형의 컴퓨터에서만 실행 가능했다. 컴퓨터 업그레이드하면 종종 모든 코드를 다 다시 작성해야 하는 사태가..

산업, 학계의 컴퓨터 전문가들과 정부가 협회를 구성하여 **데이터 시스템 언어위원회**를 만든다. (그레이스 호퍼가 고안함) 공통 프로그래밍 언어 개발을 위해!

COBOL (Common business-oriented) : 사용하기 쉽고 고수준의 공통 비즈니스 지향 언어

특징 : Write once, run aniwhere = 어떤 컴퓨터에서 실행되든 동일한 결과

그러나 여전히 CPU와는 관련있는 한계가 있다.

이 모든것은 누구든지 사용하게 하기 위함이다.

### 시대별 대표적인 언어

1960년대 ALGOL, LISP, BASIC

1970년대 PASCAL, C, Smalltalk

1980년대 C++, Objective-C, Perl

1990년대 Python, Ruby, Java

2000년대 Swift, C#, Go

# 거의 모든 프로그래밍 언어가 제공하는 것들 (기본 구성 요소)

프로그래밍 언어에도 구문Syntax이 존재한다

### 대입문 `=`

등호의 오른쪽부터 체크하자

### 변수를 초기화 Initialize

= 초기 값 정하는 것

A = 1

A라는 새로운 변수를 초기화하고 1로 설정한다는 뜻

### 제어흐름문 Control Flow Statement

If문이 가장 일반적 조건conditional

if-then-else

while (while loop) 조건이 참일동안

for loop 횟수 조정 가능 (특정 횟수)

### Functions = = Methods = Subroutines

함수 = 메서드 = 서브루틴

현대 프로그래밍에서는 100줄 넘는 함수는 찾아보기 어렵다.

모듈화!

### 라이브러리

미리 작성된 함수 묶음

거의 모든 것을 위한 라이브러리가 존재한다!

# 알고리즘

알고리즘이 현대 컴퓨터 과학을 이끌어냈다!

가장 중요한 알고리즘 문제 중 하나는 **정렬**.

컴퓨터는 항상 정렬을 사용한다! 연락처 정렬, 금액 정렬.. 등등

### 선택정렬

```
FUNCTION selectionSort(array)
	FOR i = 0 TO end of array

		smallest = i
		FOR index = i+1 TO end of array
			IF array item index < array item smallist
				smallest = index
			END IF
		NEXT

		swap array items at index and smallest

	NEXT
RETURN array
```

FOR 루프가 다르 FOR 루프 안에 포함되어 있다 = N개의 항목을 정렬하고 싶다면 N번 반복해야 한다. 그 안에서 루프를 N번 반복하면 총합은 대략 N\*N 루프 또는 N^2

입력하는 수의 크기input size와 실행되는 단계 수number of steps 사이의 관계는 선택 정렬 알고리즘의 복잡도complexity를 특징화한다.

→ 이는 얼마나 빨리 또는 느리게 알고리즘이 실행될지 근사치를 제공한다.

→ 이를 big O표기법으로 표기한다. O(n^2)

- N^2은 특별하게 효율적이지는 않다
  n = 8개 항목이라면 8의 제곱 64
  배열 크기를 80으로 늘린다면? 6400
  배열은 10배, 실행시간은 100배 증가! 커질수록 영향이 확대된다. 구글 같은 큰 회사에는 큰 문제다.

### Merge Sort 병합 정렬

1. 배열의 크기가 1보다 큰지 확인
2. 큰 경우 배열을 두 개로 나눈다
3. 1보다 여전히 크다면 계속 반복하여 두 개로 나눈다.

둘로 나눈 다음 작은 순서부터 병합하는 것

양쪽배열 숫자가 여럿 있으면 그 둘을 하나씩 비교하는 느낌

**빅O표기법상 `N * logN` 로 표기 `O(n log n)`**

N은 비교하고 합병하는 데에 필요한 횟수만큼 발생한다.

이 횟수는 정렬안의 배열 항목수와 직접 비례한다.

로그 n은 병합 단계의 수에서 나온다.

반으로 나누니까 항목 수 사이에 **로그관계**를 가지게 된다.

정렬의 크기를 8의 두배인 16으로 하면 정렬할 항목 수는 두 배 늘어남 → 분할 단계 횟수는 1번 증가할 뿐!

따라서 선택정렬보다 효율적이다

> 로그는 지수 함수의 역함수이다. 어떤 수를 나타내기 위해 고정된 밑을 몇 번 곱하여야 하는지를 나타낸다고 볼 수 있다.
>
> 2^4 = 16
>
> `2^x = 16` = `log₂16 = x`

## 그래프 서치

node와 edge로 이루어진 그래프.

### 무차별적 접근 방식 = 모든 경로 다 조사

N! (n팩토리얼)

### Dijkstra 다익스트라 알고리즘

가장 빨리 특정 node에서 특정 node로 도착하는 루트 찾는 알고리즘

그래프 안의 노드 수의 제곱만큼의 복잡도를 가진다 O(n^2) → 제곱은 효율이 좋지 않아!

몇년뒤 이 알고리즘은 개선되었다

**O(n log n + L라인수)**

구글 지도로 길찾기 같은 서비스에서 실행된다!

현대 세상은 알고리즘 없이는 생활이 불가능하다.

# 자료 구조

데이터 알고리즘이 실행되는 데이터가 어떻게 컴퓨터 메모리에 저장되는가

데이터가 읽고 불러오기 쉽게 잘 정리되어 있기 위함

## 배열=리스트=벡터

메모리에 연속적으로 저장되어있는 값

특정한 값 찾으려면 index 지정이 필요 → a[0]에서 0이 인덱스

배열은 0부터 시작하므로 인덱스가 5인 숫자는 6번째 숫자

**유사한 것 string `j = "string words"`**

메모리상에서 배열은 (이진법)0으로 끝난다 = **null 문자 = 문자열의 끝**을 나타낸다

**이게 중요한 이유는?**

만약 이 문자열을 print 같은 함수로 출력한다고 하면 언제 출력을 멈출지 알아야 하기 때문 (문자열 함수가 언제 끝나는지 알려준다)

ex. 많은 프로그래밍 언어는 두 문자열을 입력받아서 두번째 문자열을 첫번째 문자열의 끝에 복사해주는 string concatenation = strcat (연속 문자열)이라는 함수를 갖고 있다.

### 2차원 배열

2차원으로 다루고 싶을 때 필요한 것 MATRIX 행

인덱스 두개 필요 j[2][1]

### 구조체 struct

연관된것 같이 저장하려면

변수 그룹은 struct(구조체)로 묶을 수 있다

**복합데이터로 된 변수**

배열은 만들어질 때 크기 고정됨, 더 확장되지 않음. 중간에 새로운 값 넣기 아려움

**하지만 Struct 데이터 구조를 사용하면 보다 복잡한 구조를 저장 가능!**

## Linked List

각 node가 목록의 다음 노드 가리키도록 **pointer 지정**

**값 & pointer 값**

이렇게 CIRCULATE가 되는데 다음 포인터 값을 null로 해주면 끝나게 된다 (null은 끝에 도달했다는 뜻)

크기를 상황에 따라 늘이거나 줄이기 가능. 포인터만 바꾸면! = **유연성**

**정렬 알고리즘에도 유용하게 쓰인다**

이걸 기반으로 하는 것이 QUEUE와 STACK

### QUEUE

줄서기

### STACK

팬케이크 더미

push로 추가, pop으로 뺀다

### 2개의 포인터가 있다면 Tree구조 만들 수 있다

맨 끝의 노드 리프 노드

뿌리에서 잎까지의 하나의 길이 존재한다는 게 중요

## 무한 루프같은 건 그래프 데이터 구조를 사용한다

무엇이든 아무거나 가리킬 수 있어서

### 각 자료구조들은 특정 계산에 유리하다

따라서 알맞는 걸 선택해야 한다!

라이브러리에 이미 만들어진 자료구조들로 가득하다.

예를들어 C++은 Standard Template Library, 자바는 Java Class Library

# 컴퓨터 과학의 아버지 앨런 튜링

### 튜링머신

가상의 컴퓨팅 머신

이론적인 계산 장치

state, srule, read, write가 존재

충분한 시간과 메모리만 있으면 어떤 계산이든 할 수 있다는 걸 보여준다

컴퓨팅 모델로서의 강력한 아이디어

이것보다 더 강력한건 Turing Complete라고 부른다

모든 문제를 계산으로 증명할 수 있는 건 아니다 = 즉 컴퓨터의 능력에는 한계가 있다 (시간이나 메모리가 아무리 많아도)

### Bombe

암호 해독. 가능한 에니그마 설정의 수를 줄이기 위함

### 튜링테스트

인간을 속여서 인간이라고 믿게 만들 수 있다면 Intelligent 라고 부를 자격이 있다는 튜링의 주장에서 기반함.

공개 튜링 테스트가 바로 captcha

# 소프트웨어 공학

마가렛 해밀턴이 만든 용어

정렬 알고리즘은 프로그램의 훨씬 더 작은 부분.

MS오피스는 코드라인이 4천만개다. 이런 거대한 프로그램을 만들기 위해서 소프트웨어 공학이 필요하다.

### Object oriented Programming

함수를 계층구조로 패키지화

관련된 코드를 객체로 모으는 것

객체는 다른 객체와 함수를 포함할 수 있다

### 복잡성을 숨기고 선택적으로 그것을 드러내는 것이 본질

크고 복잡한 프로그램을 만드는 대중적이고 강력한 방법!

### API 공동으로 작업하는 방식

Application Programming Interface

적절한 접근 권한을 알 수 있다

### 함수의 private public 설정 가능

private = 해당 객체 내부의 함수만 호출할 수 있다

## IDE

컴파일 되기 전 코드는 텍스트에 불과하다

테스트와 디버깅에 7-80퍼의 시간을 쓰는 프로그래머들

## 문서화도 중요!

readme, 주석

코드 재사용reuse 촉진

## 소스 컨트롤 = 버전 컨트롤 = 리비전 컨트롤

공동 작업을 돕는 소프트웨어

중앙집중화된 코드 repo에 저장된다

## 테스트

QA

알파 버전 : 내부 테스트 (더 러프하다)

베타 버전 : 외부 테스트

# 집적 회로와 무어의 법칙

지금까지 살펴본 발전들은 하드웨어의 개선 없이는 불가능했다.

## 1세대

### Tyranny of Numbers

초기 전자컴퓨터는 전부 별개의 부품으로 구성되어 있어 ENIAC 같은 경우는 500만건의 납땜이 필요하기도. 그래서 성능을 더 올리려면 그 각각의 부품의 개수를 늘리는 수밖에 없었다.

## 2세대

이후 트랜지스터가 상용화되어 컴퓨터에 통합. 그러나 여전히 하나의 개별 부품이었다.

전자 컴퓨팅 2세대 : 트랜지스터화된 컴퓨터

하지만 아직도 숫자의 폭력은 해결하지 못해..

1960년대에 한계에 도달.

내부는 엄청난 양의 전선 엉킴으로 가득했다.

## 3세대

### IC 집적 회로 Intergrated Circuit

개별 부품을 선으로 잇는 대신 새 하나의 부품안에 많은 부품을 함께 넣는것

Noyce가 실리콘으로 만들게 된다

IC는 빌딩 블록인 레고와 비슷하다

### 인쇄 회로 기판 PCB Printed Circuit Boards

방대한 수의 선을 납땜하고 번들링하는 대신, 금속 와이어를 엣칭

### PCB와 IC를 함께 사용하면

이전과 같은 기능을 더 저렴하고 작고 믿을만하게 만들 수 있다!

하나의 IC에 5개이상의 트랜지스터 쓰기 어려워..

그래서 등장한 공정👇

### Photolithography 사진 석판술

복잡한 패턴을 반도체같은 물질에 빛을 이용해 이동시키는 방법

실리콘은 반도체 (반도체는 전기를 전도할 수도 있고 안할 수도 있는 것)

Photoresist는 Photomask랑 사용할 때 유용함. 마스킹하여 선택적으로 Oxide Layer로 실리콘을 덮을 부분을 남길 수 있다. 즉, 회로 연결에 필요한 모든 선을 단일 실리콘 조각으로 만들 수 있다!

**이제 개별 부품이 필요 없다**

## 무어의 법칙

2년마다 2배의 트랜지스터 장착이 가능하다는 것. 100% 맞지는 않지만 기술 발전을 나타내기에 적합한 말이다.

사유는 트랜지스터를 더 작게 만들 수 있는 기술력 발전.

**트랜지스터가 작을수록 이동이 적어서 소비전력도 준다. 신호 지연도 적고!**

1980년 CPU에는 트랜지스터 8만개

1990년 백만게

2000년 3천만개

2010년 십억개.. IC하나에…

이러한 발전으로 전자제품 대부분이 기하급수적으로 발전 (뭐든지)

Noyce&Moore → Intel 설립!

Integrated + Electronics

**마이크로프로세서 = IC**

컴퓨팅 3세대의 시작

## 4세대

자동으로 칩 디자인 생성하는 소프트웨어를 사용한다

소프트웨어가 가장 효율적인 방법으로 회로 디자인

4세대 컴퓨터의 시작

무어의 법칙은,, 정밀도에 대한 한계때문에 종말 얘기가 나오고 있다.

# 운영체제

컴퓨터가 스스로 프로그램을 실행할 수 있는 능력이 필요해짐.

그렇게 탄생한 운영체제 Operating System

**다른 프로그램을 실행하고 관리할 수 있다.**

컴퓨터 전원 켰을 때 시작하는 프로그램

### Batch Processing 일괄 처리

1950년대에 시작되었다.

처음에는 수동 작업(직접 펀치카드 넣는..) 보강 용도

하나를 완료하면 자동으로 다음을 시작 (즉시) **= Batch Processing 일괄 처리**

### Device Drievers

초기 프로그래머들의 고통을 덜어주기 위해 운영체제는 소프트웨어 프로그램과 하드웨어 주변 장치의 중개자로서의 단계를 밟았다.

구체적으로, 장치 구동기 Device Drievers 라고 불리는 API를 통해 소프트웨어 추상화 제공

이를 통해 프로그래머는 표준화된 매커니즘을 사용하여 입출력input&output 하드웨어 = I/O와 대화할 수 있었다.

### 세계 최초의 슈퍼컴퓨터 아틀라스

동시에 여러개의 프로그램을 단일 CPU에서 실행하도록 영리하게 설계됨.

(당시 기계식 프린터 등의 주변기기는 전자CPU에 비해 느렸다)

I/O가 끝날때까지 기다리지 않고 다음 대기중인 프로그램 실행하고 있도록 함 **= 멀티 태스킹**

### 가상 메모리

멀티태스킹의 걸림돌, 메모리

이는 각 프로그램에 자체 메모리 블록 할당으로 해결 가능.

이 방법의 단점은 순차적 블록이 아니라는것

프로그래머가 계속 추적하기엔 혼란스럽다!

이 복잡성을 숨기기 위해 운영체제는 메모리 위치를 **가상화**한다

가상 메모리 virtual memory 를 사용하면 프로그램은 메모리가 항상 주소 0에서 시작되어 단순하고 일관되게 유지한다고 가정할 수 있다. 실제 물리적 위치는 운영체제에 의해 추상화되어 숨겨져있다.

이 메커니즘으로 프로그램은 메모리 크기를 유연하게 할 수 있다 = **dynamic memory allocation 동적 메모리 할당**

운영체제에 엄청난 유연성 제공!

서로로부터 더 잘 격리되는 것도 장점! 문제가 생겼을 때 다른 프로그램 메모리를 건드리지 않을 수 있다 memory protection 메모리 보호 (바이러스 등에서 보호)

**아틀라스는 가상, 보호 메모리를 전부 가진 최초의 컴퓨터 및 OS**

## UNIX

이제 운영체제는 여러 프로그램, 여러 사용자(터미널) handle 가능

개별 사용자는 시간 공유를 통해 자원 중 일부분만 활용 가능

Multics

→ UNIX

OS를 두 부분으로 분리하고자 함

1. **커널 : I/O를 다루는 기능인 메모리 관리, 멀티태스킹과 같은 OS의 핵심 기능**
   - 의도적으로 일부 기능만 남기는 것
   - 커널 패닉 : 복구 수단이 없어서 패닉이라는 기능 호출. 원래 패닉이라는 단어 인쇄하고 무한 루프로 들어갔음
     - 이런 **단순함** 덕분에 다양한 하드웨어에서 돌아갈 수 있음!
       - 많은 곳에서 사용되었다.
       - 7,80년대 가장 인기있는 OS 중 하나
     - 1981 MS-DOS 출시
       - 멀티 태스킹과 보호된 메모리가 부족하다는 특징들은 그대로
         - 충돌이 있다 (재부팅)
     - 1985 윈도우 초기 버전
       - 이조차 메모리 보호기능이 없었기에 프로그램이 잘못 수행되면 → 블루 스크린
       - 최신 버전은 더 나은 보호 기능 제공, 충돌 거의 없다
         - 그래서 여러 프로그램을 한번에 실행할 수 있는 것
2. 추가적으로 제공되지만 커널이 아닌 프로그램과 라이브러리 같은 유용한 도구들
